## **Index**
- [**Index**](#index)
- [**DAO Audit Report**](#dao-audit-report)
- [**General Comments **](#general-comments-)
- [**Static Analysis**](#static-analysis)
- [**[H-1] External function without access control restriction.**](#h-1-external-function-without-access-control-restriction)
- [**[H-2] Proposal state check before execute.**](#h-2-proposal-state-check-before-execute)
- [**[M-1] Casting votes to arbitrary proposal.**](#m-1-casting-votes-to-arbitrary-proposal)
- [**[L-1] Wrong check for repeatability.**](#l-1-wrong-check-for-repeatability)
- [**[F-1] Extra Feature: Extra functions.**](#f-1-extra-feature-extra-functions)
- [**[Q-1] Natspec documentation.**](#q-1-natspec-documentation)
- [**[Q-2] Modifier not used.**](#q-2-modifier-not-used)
- [**[Q-3] Unnecessary data in event.**](#q-3-unnecessary-data-in-event)
- [**[Q-4] Unnecessary data in mapping.**](#q-4-unnecessary-data-in-mapping)
- [**[Q-5] Not checking current funds.**](#q-5-not-checking-current-funds)
- [**[Q-6] Different approach on similar functionalities.**](#q-6-different-approach-on-similar-functionalities)
- [**[Q-7] Using extra memory space.**](#q-7-using-extra-memory-space)
- [**[Q-8] Variable declarations.**](#q-8-variable-declarations)
- [**[Q-9] Unnecesary check.**](#q-9-unnecesary-check)
- [**Nitpicks**](#nitpicks)


## **DAO Audit Report**

The requirements for this project is to create an DAO for the main purpose of collecting NFTs assets.


This micro audit was conducted by Agustin Bravo student of block 6 of the Macro Solidity bootcamp.

## **General Comments **

The contract follows the lines of Governor Alpha of Compound protocol, implementing the NFTs buys of the given marketplace interface. I'd recomend you to use the _hardhat coverage_ report and try to cover more % of statements, branches and functions. I always try to test at least a 90-95% of the contracts at least :) 

Also inside the coverage folder generated by the command _npx hardhat coverage_ you will have an _index.html_ that will give you a complete analysis on your tests reach. Here is your coverage report of Collector.sol:


File                     |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |
-------------------------|----------|----------|----------|----------|----------------|
Collector.sol            |    58.04 |    42.86 |    47.62 |     56.3 |... 460,461,466 |


Also you should try to use _slither_ tool for static analysis, it helped me a lot to show me potencial vulnerabilities in my code! 

## **Static Analysis**

The execution of static analysis _slither_ identified 28 potential issues within the codebase of which 19 were ruled out to be false positives or negligible findings.

The remaining 9 issues were validated, grouped and formalized into these two points:

- Sends eth to arbitrary user. (Normally wouldn't be a problem but in this case the function doesn't have any control access restriction)
- Reentrancy vulnerability. (Medium-High vulnerability)
- Function not used. (Code quality)
- Parameters in public functions not using mixedCase. (Code quality)
- Constant declarations not in UPPER_CASE_WITH_UNDERSCORE. (Code quality)

## **[H-1] External function without access control restriction.** 

On line 220, Collector.sol has the following code:

```
    function executeTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data
    ) public payable returns (bytes memory) {  
``` 

This function allows any user to call arbitrary functions without any restrictions, a malicious address can transfer all the contract funds anywhere he wants.
Consider: If this function is used by the contract to call the functions of the proposal consider to add a verification of the `msg.sender` like `require(msg.sender == address(this))`.

## **[H-2] Proposal state check before execute.** 

On line 252, Collector.sol has the following code:

```
    function execute(uint256 proposalId) public payable {   /// AUDIT NOT CHECKING ANY WHERE IF THE QUORUM IS FOR OR AGAINST THE PROPOSAL ANY PROPOSAL CAN BE EXECUTED
        require(
            proposals[proposalId].id > 0,
            "Collector::execute: Proposal does not exist"
        );

        Proposal storage proposal = proposals[proposalId];

        //check to see if quorum of 25% is met
        bool hasQuorum = proposal.proposalMemberCount * 4 >= totalMemberCount;
        require(hasQuorum, "Collector::execute: Quorum not met");
        proposal.executed = true;       /// AUDIT SETTING proposal.executed treu BUT NEVER REQUIRING IT FALSE
        for (uint256 i = 0; i < proposal.targets.length; i++) {
            executeTransaction(
                proposal.targets[i],
                proposal.values[i],
                proposal.signatures[i],
                proposal.calldatas[i]
            );
        }
        emit ProposalExecuted(proposalId);
    }
``` 

The `execute` function is not checking the conditions:
  - `yesVotes` or `noVotes` and will be executed no matter the support of the proposal. Only by reaching the quantity of votes. 
  - `executed` if the proposal has already been executed. This could lead to a proposal being executed multiple times. 

## **[M-1] Casting votes to arbitrary proposal.** 

On line 362, Collector.sol has the following code inside `bulkCastVotesBySig` function:

```
            ...
        for (uint256 i = 0; i < _sigs.length; i++) {
            bytes memory sig = _sigs[i];        
            string memory message = _messages[i];
            Proposal storage proposal = proposals[i]; /// AUDIT USING CUALQUIERA PROPOSAL ID

            bytes32 messageHash = getMessageHash(message);
            bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);
            address signer = recoverSigner(ethSignedMessageHash, sig);
            (bytes32 r, bytes32 s, uint8 v) = splitSignature(sig);
            ...
``` 

The `Proposal storage proposal`  pointer will be assigned to `proposals[i]` while `i` being the auxiliary variable that loops the code. This by no means has any logic to use this proposals ids and will never allow any signature to be correctly cast.

Consider: Adding the `proposalId` to the inputs of the function.

## **[L-1] Wrong check for repeatability.** 

On line 375, Collector.sol has the following code inside `bulkCastVotesBySig` function:

```
            ...
            Receipt storage receipt = proposal.receipts[signer];
            require(
                receipt.hasVoted,
                "Collector::tallyVote: voter has not voted"
            );
            ...
``` 

Consider: The require statement should check that the signer **hasn't** voted yet to cast the vote:

```
            ...
            Receipt storage receipt = proposal.receipts[signer];
            require(
                !receipt.hasVoted,
                "Collector::tallyVote: voter has already voted"
            );
            ...
``` 

## **[F-1] Extra Feature: Extra functions.** 

On Collector.sol, line 451:

```
    // Helper math function borrowed from Compound Governor
    function add256(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "addition overflow");
        return c;
    }

    // Helper math function borrowed from Compound Governor
    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "subtraction underflow");
        return a - b;
    }
```

Since the solidity compiler version 0.8.0 the underflow and overflow checks for arimetic operations are built in, if an arimetic operation undeflows or overflows the transaction will revert.

Consider: Deleting unnesesary math helpers if pragma solidity is > to version 0.8.0. If the in built checks are not need you can use the `unchecked{ a+b }` syntax.

## **[Q-1] Natspec documentation.** 

The following functions don't have any comments:
    -`function getEthSignedMessageHash`.
    -`function getMessageHash`.
    -`function verify`.
    -`function bulkCastVotesBySig`.
    -`function castVoteBySig`.
    -`function _castVote`.
    -`function state`.
    -`function execute`.
    -`function executeTransaction`.
    -`function propose`.
    -`function proposeNft`.

Also the functions and declarations that do have comments don't follow the natspec format recommended by solidity documentations.

Consider: Using natspec recommended documentation methods in all declarations. Source: https://docs.soliditylang.org/en/latest/natspec-format.html

## **[Q-2] Modifier not used.** 

On Collector.sol, line 111:

```
    modifier onlyAdmin() {          /// AUDIT QUALITY NON USED MODIFIER
        require(msg.sender == admin, "Collector::onlyAdmin: user is not admin");
        _;
    }
```

This modifier is not being used in the contract and will add bytecodes and gas cost to the deployment.

Consider: Removing unnecessary modifiers and functions.
    

## **[Q-3] Unnecessary data in event.** 

On Collector.sol, line 91:

```
    event ExecuteTransaction(
        bytes32 indexed txHash,
        address indexed target,
        uint256 value,
        string signature,
        bytes data
    );
```

This event is emitting unnecessary index data, the txHash most certantly will be unique in most of the cases, the indexed keyword won't be showing more than the unique transaction. Also this hash of the transaction data is not useful and could be generated off chain by the `target`, `value`, `signature` and `data`. 

Consider: Not emitting unnecessary values in events.

## **[Q-4] Unnecessary data in mapping.** 

On Collector.sol, line 16:

```
    struct Proposal {
        uint256 id; // id of the proposal
        address proposer; // address that created the proposal
        address[] targets; // target addresses for calls to be made
        uint256[] values; // values to for calls to be made
        string[] signatures; // function signatures to be called
        bytes[] calldatas; // calldatas to be called
        uint256 voteCount; // number of votes accumulated
        uint256 yesVotes; // number of votes in favour of proposal
        uint256 noVotes; // nunber of votes against proposal
        uint256 startBlock; // The block at which voting begins
        uint256 endBlock; // The block at which voting ends
        bool executed; // if proposal has been executed
        mapping(address => Receipt) receipts; // records who has voted for this proposal
        uint256 proposalMemberCount;
    }
```

The struct of every proposal is storing the id, but this value is already used in the mapping key to access that proposal. 

```
mapping(uint256 => Proposal) public proposals;
```

Consider: Including redundant data will result in more gas costs.

## **[Q-5] Not checking current funds.** 

On Collector.sol, line 166 on function propose a proposal could have wrong values not owned by the contract, this will lead to the proposal failling.

Consider: Checking that the total sum of values is in the contract.

## **[Q-6] Different approach on similar functionalities.** 

Functions `castVoteBySig` and `bulkCastVotesBySign` do have the same functionalities but the last one only extend the first function for multiple calls.

Even though this functions are similar both are using different methods to verify the signature calls, one using `ecrecover` on `v`, `r` and `s` that are input parameters, and the other is spliting the signature inside the contract.

Consider: Using only one of the two methods to avoid unnecessary code, gas costs and confusion inside the contract.

## **[Q-7] Using extra memory space.** 

On Collector.sol, line 354:

```
    function bulkCastVotesBySig(bytes[] memory _sigs, string[] memory _messages) 
        public
    {
        require(
            _sigs.length == _messages.length,
            "Collector::bulkCastVotes: args must be the same length"
        );

        for (uint256 i = 0; i < _sigs.length; i++) {
            bytes memory sig = _sigs[i];       
            string memory message = _messages[i];
            Proposal storage proposal = proposals[i];

            bytes32 messageHash = getMessageHash(message);
            bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);
            address signer = recoverSigner(ethSignedMessageHash, sig);
            (bytes32 r, bytes32 s, uint8 v) = splitSignature(sig);
            ...
```

Function `bulkCastVotesBySig` is declaring new memory variables inside the loop and assigning memory input variables to them.

Consider: Declaring memory variables outside loops and avoid declaring unnecesary memory variables to reduce gas costs:

```
    function bulkCastVotesBySig(bytes[] memory _sigs, string[] memory _messages) 
        public
    {
        require(
            _sigs.length == _messages.length,
            "Collector::bulkCastVotes: args must be the same length"
        );

        for (uint256 i = 0; i < _sigs.length; i++) {    
            Proposal storage proposal = proposals[i];

            bytes32 messageHash = getMessageHash(_messages[i]);
            bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);
            address signer = recoverSigner(ethSignedMessageHash, _sigs[i]);
            (bytes32 r, bytes32 s, uint8 v) = splitSignature(_sigs[i]);
            ...
```

## **[Q-8] Variable declarations.** 

On line 59, Collector.sol has the following variable declarations:

```
    uint256 public constant proposalMaxOperations = 10; // the max number of actions per proposal

    uint256 public constant votingDelay = 1; // 1 block delay before voting starts

    uint256 public constant votingPeriod = 17289; // 3 days in blocks at 15s per block

```

Consider: Constant variables should be UPPER_CASE_WITH_UNDERSCORE. Source: https://docs.soliditylang.org/en/latest/style-guide.html#constants

## **[Q-9] Unnecesary check.** 

On line 194, Collector.sol has the following line:

```
        require(newProposal.id == 0, "Collector::propose: ProposalID collsion");
```

This require is useful if the proposalId is generated by the hash or the input info, this could lead to a proposal being identical to other and result in the proposal never being executed. In this case the proposal id is equal to the `proposalCount` that is incrementing with every proposal.

Consider: Removing unnecessary requires to improve readability and avoid gas costs.

## **Nitpicks** 

- Using `address(this).balance`: Use a storage variable to track funds, this would be more solid to users and clear to manage in a DAO scenario. If donations or other system to raise funds exist, add the contributions to storage (When executing proposals the variable should substract those values).
- `proposeNft` could have the onlyMember modifier to avoid spending gas and reverting before calling `propose` function.
- In `state` function the last return value doesn't have any conditions. Consider using `else if` with all possibilities to improve readability.
- functions `state` and `execute` use the same line for quorum ` bool hasQuorum = proposal.proposalMemberCount * 4 >= totalMemberCount;` consider using an internal function to avoid duplicate code.

